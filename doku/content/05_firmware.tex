%!TEX root = ../dokumentation.tex

% Kapitel über Firmware des Mikrocontrollers
% Sprache, Funktionen, Schnittstellen, ...


\chapter{Firmware}
Als Firmware wird die Software bezeichnet, welche auf dem Mikrocontroller ausgeführt wird. Sie läuft ohne Betriebssystem direkt auf der Hardware und kann in Assembler, C oder anderen hardwarenahen Programmiersprachen geschrieben werden. In diesem Fall wurde sie mit C und den dazugehörigen Bibliotheken für die AVR-Mikrocontroller entwickelt.\\
Die Firmware hat die Aufgabe die Hardware des Controllers zu steuern. Sie ist in Module aufgeteilt, die jeweils für eine Hardwarekomponente zuständig sind:
\begin{description} %TODO Eigene Überschriften statt description?
	\item[LED-Statusanzeige:] Die LEDs werden über die \ac{GPIO}-Pins des AVR angesteuert. Per Software-\ac{PWM} lassen sich auch sanft pulsierende Signale realisieren. Damit kann der Controller mitteilen, in welchem Zustand er sich befindet und dass die Firmware nicht hängen geblieben ist.
	\item[7-Segment-Anzeige:] Die Platine mit den vier 7-Segment-Ziffern zur Anzeige von Messergebnissen benötigt ein extra Modul, um diese Anzusteuern. Das geschieht über eine serielle Verbindung zu vier hintereinander geschalteten Schieberegistern. Die Werte werden per \ac{Bitbanging} über die \ac{GPIO}-Pins in die Register geschoben, diese haben parallele Ausgänge, die mit den Ziffern verbunden sind.
	\item[Signalerzeugung mit \ac{PWM}:] Das $40kHz$-Signal für den Ultraschallsender wird von der Mikrocontroller-Hardware erzeugt. Dazu wird ein Zähler benötigt, der bei einem Vergleichswert und beim Überlauf den Pegel eines Ausgangspins setzt. Die Firmware initialisiert und startet den Timer, die Erzeugung des Signals wird ausschließlich von der Hardware erledigt. Dadurch wird das Signal sehr präzise und die Rechenleistung des Mikrocontrollers steht für andere Zwecke zur Verfügung.
	\item[Laufzeitmessung:] Für eine präzise Zeitmessung wird ein weiterer Hardwarezähler verwendet. Er wird in einer konstanten Frequenz inkrementiert, bis das Signal eingetroffen ist. Wenn das Zählerregister zu klein ist, kann bei einem Überlauf ein weiteres Register inkrementiert werden, damit die Messgenauigkeit und -Reichweite nicht durch die Software eingeschränkt werden müssen.
	\item[Signalerkennung:] Empfängt der Ultraschallempfänger ein Signal, so erhält der Mikrocontroller einen digitalen Puls. Auf einem Interrupt-Eingang löst die Flanke dieses Signals einen Sprung in der Firmware aus, sodass der Hardwarezähler sofort gestoppt werden kann. Ein Interrupt erhöht die Präzision der Messungen, da die Software alleine nur sequentiell den Signalpegel abfragen könnte und die Zeitpunkte ungenau werden. Zudem können die Flanken nicht aufgrund anderer Rechenaufwänden verpasst werden.
	\item[\ac{TWI}-Kommunikation:] Die serielle Schnittstelle wird verwendet, um mit dem Raspberry Pi zu kommunizieren. Als Slave muss der Controller auf Anfragen reagieren, es können Messungen angefordert und Ergebnisse ausgelesen werden. Die AVR-Mikrontroller besitzen eine \ac{TWI}-Hardware, die von der Firmware genutzt wird.
\end{description}


\section{Genauigkeit und Reichweite der Messungen}
Die Messgenauigkeit und maximale Reichweite ist durch den Takt des Zählers, sowie die Bitbreite des Messwertes abhängig. Die Firmware taktet den Zähler mit $1MHz$ und speichert die Daten in einem 16-Bit Register. Daraus ergeben sich folgende Werte:\\
Schrittlänge:
\begin{equation} %TODO Schallgeschwindigkeit zw 20-25° 344-245 m/s
\Delta s = \frac{u}{f} = \frac{343m/s}{1*10^6 1/s} = 0.343 mm
\end{equation}
Maximale Distanz:
\begin{equation}
dist = 2^{16} * \Delta s = 22.48 m
\end{equation}

Der Wert bezieht sich auf die relative Genauigkeit. Offsetfehler, die durch Latenzzeiten entstehen, können in einem gewissen Umfang experimentell bestimmt und herausgerechnet werden. Die relative Genauigkeit hängt allerdings von der Toleranz des internen Taktes ab, dieser wird vor allem bei Temperaturänderungen ungenauer. Bei starken Abweichungen kann der Mikrocontroller über einen genaueren externen Quarz getaktet werden.

\section{Erkennung der Platine durch die Firmware}

